+++
title = "The Weight of Software"
[taxonomies]
categories = ["software"]
+++
There is a common believe about software that it is essentially
weightless, that copying it is essentially free, and that it
does not age. This strikes me as the kind of fact that is technically
true, but of very little practical value, like proving that some
system is Turing complete and stating that it can do any computation
you want it to. Technically true, at least in a certain sense,
but not interesting.


What I mean by this is that software has a lot of properties
that physical objects have. The actual copying of software is
cheap, but if you make a copy and give it to someone, they
have to invest resources to use it- to compile, deploy,
understand, modify, etc. It can actually be very 
resource intensive to "copy" the knowledge into
another person.


Software also has a certain weight to it- larger software has
an inertia that makes it hard to change. Large software
can be hard to install, and it can be
fragile in its dependencies as if it were a building
with a shifting foundation. Software size is very
much correlated to complexity and bugs.


For aging- software seems to bit-rot much faster than I
ever expect it to. It may only work on one machine, or
stop working due to dependencies or operating system updates,
or any number of things. In fact, there seems to be
a great deal of software that is in a constant state
of decay and requires manual renewal to maintain.
Sometimes it seems that the most enduring software is
not Lisp or Forth, or any other of the more 'pure' 
languages that one might be able to implement oneself
to restart computation from scratch, but rather,
in practice, good ol' POSIX compliant C.


Overall software feels like a terribly complex,
constantly falling apart mechanism in many cases.
This is far from the ideal free to copy, unaging,
machines that it is sometimes imagined to be.
